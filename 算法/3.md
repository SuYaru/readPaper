### 0-1 背包问题

---

给你一个可装载重量为 W 的背包和 N 个物品，每个物品有重量和价值两个属性。其中第 i 个物品的重量为 wt[i]，价值为 val[i]，现在让你用这个背包装物品，最多能装的价值是多少？

举个简单的例子，输入如下：

```
N = 3, W = 4
wt = [2, 1, 3]
val = [4, 2, 3]
```

算法返回 6，选择前两件物品装进背包，总重量 3 小于 W，可以获得最大价值 6。

##### 动态规划解法

1. 第一步要明确两点，「状态」和「选择」
   所以状态有两个，就是「背包的容量」和「可选择的物品」。
2. 第二步要明确 dp 数组的定义
   dp[i][w]的定义如下：对于前 i 个物品，当前背包的容量为 w，这种情况下可以装的最大价值是 dp[i][w]。
   根据这个定义，我们想求的最终答案就是 dp[N][w]。base case 就是 dp[0][..] = dp[..][0] = 0，因为没有物品或者背包没有空间的时候，能装的最大价值就是 0。

   ```
   int dp[N+1][W+1]
   dp[0][..] = 0
   dp[..][0] = 0

   for i in [1..N]:
       for w in [1..W]:
           dp[i][w] = max(
               把物品 i 装进背包,
               不把物品 i 装进背包
           )
   return dp[N][W]
   ```

3. 第三步，根据「选择」，思考状态转移的逻辑。

   - 如果你没有把这第 i 个物品装入背包，那么很显然，最大价值 dp[i][w]应该等于 dp[i-1][w]。你不装嘛，那就继承之前的结果。
   - 如果你把这第 i 个物品装入了背包，那么 dp[i][w]应该等于 dp[i-1]w-wt[i-1]] + val[i-1]。

   ```
   for i in [1..N]:
       for w in [1..W]:
           dp[i][w] = max(
               dp[i-1][w],
               dp[i-1][w - wt[i-1]] + val[i-1]
           )
   return dp[N][W]
   ```

4. 最后一步，把伪码翻译成代码，处理一些边界情况

   ```
   function fn(W, N, wt, val) {
   const cacheArr = Array.from(new Array(N + 1), () => new Array(W + 1).fill(0));
   for (let i = 1; i <= N; i++) {
       for (let j = 1; j <= W; j++) {
       if (wt[i - 1] > j) {
           // 当前背包容量装不下，只能选择不装入背包
           cacheArr[i][j] = cacheArr[i - 1][j];
       } else {
           // 装入或者不装入背包，择优
           cacheArr[i][j] = Math.max(
           cacheArr[i - 1][j],
           cacheArr[i - 1][j - wt[i - 1]] + val[i - 1]
           );
       }
       }
   }
   return cacheArr[N][W];
   }
   ```
