# 框架

## vue相关

- vue双向绑定原理
   - Vue2.0中，data中返回的所有数据会被转为getter/setter。每个组件都会建立一个watcher对象，在渲染该组件的时候，watcher会把所有用到data中的数据属性记录在一个dep的数组中，作为依赖项。当数据中的setter触发时，会通知watcher对所有和该数据相关的dom进行重新渲染。
   - vue3.0中，data中返回javaScript对象时，vue对其进行包装，使其成为一个proxy对象，并对每一个属性生成一个副作用，且在get中对当前属性进行跟踪，记录其副作用，当该属性数据被更改时调用set 触发依赖该属性的副作用。

   vue2中需要先定义数据，然后根据数据进行遍历Object.defProtype来重写get和set。是在属性层面的拦截。proxy直接在对象层面进行拦截，拦截属性的设置和读取。可以检测到响应式数据的增减，vue2无法检测到响应式数据增加属性

- v-model
   - v-model是一个语法糖，可以理解为是v-bind:value的简写模式。根据控件的不同选择不同的实现方式：input为input事件
- keep-alive原理
   - keep-alive通过缓存当前组件实例。根据组件ID和tag生成缓存Key，如果该实例存在，则更新key的位置（LRU放在最后面），如果不存在：超过最大值则使用最近最少使用的原则更新缓存，否则直接进行缓存该实例和key的值。
- 动态路由如何实现（根据权限）
   - 在初始化项目的时候，先通过接口获取到用户的权限，再根据权限加载不同的菜单页
- 组件传参的方式及优缺点
   - eventBus:方便简单，在需要传参的地方引入并抛出事件、需要监听的地方引入增加监听事件即可。
   - Store 通过组件间共享某个属性，通过改变属性进行传参。方便，不需要层级递进，数据变化感知可交由commpute或者getter进行处理，不需要手动监听。
   - Props 父子组件之间的传参：兄弟节点之间的传参比较复杂，需要层级递进传出，子组件中对数据的修改需要emit抛出，在父组件中更新以驱动do m变化。
- compute 和watch区别
   - Computed 只在依赖的数据进行改变时进行计算返回，引用类型的数据发生变化。例如数组中的数据发生变化则不会进行重新计算。依赖多个数据的场景用computed
   - computed是和data一样，作为数据属性存在的
   - watch可监控data或者compute中的属性,影响多个数据用watch
- 自定义指令
- 生命周期
   - 父组件和子组件：
      - 父create=>子create=>子mounted=>父mounted=>子update=>父update=>子destroyed=>父destroyed
      - 第一次初始化的时候mounted=>activated.
- vue的编译原理

active 和 mounted的先后顺序

生命周期的过程=》渲染过程详细描述每个阶段做什么

## 难点：

通过数据的不同渲染不同的dom在当前页面上，由于数据的变化导致循环体内的dom频繁的对比销毁和重建。

解决思路1:

通过vue的router进行tab页切换，利用同一个组件进行动态路由的增加

结果：随着循环体内的数据发生变化，循环内的dom还是会发生销毁重建的过程，循环外的dom太少，影响不到性能。所以该方法行不通

思路二：

懒加载，利用vue-lazylod-component进行懒加载：只渲染当前页面的dom。具体实现原理为dom的新接口（交叉观察器）

## react相关

