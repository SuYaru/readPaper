# 面前准备

第一句话：是什么，第二句话，什么业务场景，第三句话，架构是什么，或者由哪些模块构成，第四句话，自己的主要贡献。

面试官，您好，我叫姬瑞彤，19年毕业于浙江大学。本科就读于西北大学。

bix报表设计器是一个数据可视化的低代码报表设计系统。主要分为设计器和渲染器两部分，设计器是用vue＋elementui实现的，用来设计报表。渲染器是用来处理设计器的输出结果。最终产物是一个有交互能力的html页面。

我做的任务管理器类似于飞书任务。主要功能有富文本编辑、多人评论、实时更新任务状态等。我负责整个应用从搭建到上线。

多维表格是与飞书多维表格类似的表格文档。主要为了解决富文本中表格无法进行计算而推进的一个项目。目前有7种列类型的展示与计算能力。技术栈是canvas+react。

难点：

组件树计算耗时，减少组件树的计算

render耗时，减少canvas绘制指令的执行。

项目介绍：::(加框架介绍)::

在美团主要负责的是与工作效率相关的产品，按由近到远的顺序、主要有学城多维表格文档、任务。

**学城是美团的wiki知识库系统，具有传统目录结构的文档编辑管理和评论点赞收藏等社交功能。多维表格是其中的一种文档格式。主要是为了解决**学城表格不支持计算、csv直接转在线表格，大数据量卡顿等问题。其中用到的技术栈是canvas和react。使用封装了canvas的zrender进行表格绘制，react处理需要用户操作输入的交互。

对于用户来说，新建一个多维表格，会默认使用表格视图，用户可以从表格视图切换到其他视图类型，切换试图的过程中使用的是同一个数据。以表格视图为例：展示出的ui界面就是一个二维表格，由表头和具体的表格体组成。但是与传统的excel不一样的是，每个单元格内的展示内容是带有样式与复杂交互的，比如文本列可以展示链接、人员列有人员的头像、姓名等。用户可以双击单元格，唤起对应列的一个编辑框，修改当前单元格内的值；也可以双击表头，对当前列的格式或者配置进行修改。

以上内容是用户角度的界面。多维表格支持这些能力，主要是一个4层架构的sdk。在这个多维表格的架构中：

从下往上，第一层是模型层，主要负责表格中所有的运算逻辑（包含筛选、排序、分组、求和等）。第二层是渲染层，渲染层是一个基于zrender的Group能力封装的组件化渲染器，可以让开发者以类似react的class的方式进行组件化的开发，无需关注canvasApi的实现。第三层是视图层，视图层是对渲染层的应用，每个视图类型主要负责当前类型的布局和排版工作。最后一层是业务层，业务层负责数据的具体展现形式及交互形式：业务层需要将每个列的渲染逻辑、编辑逻辑通过注入的方式注入到视图层中。比如：数据在每个单元格的展示形式，由业务层自定义实现一个组件，这个组件最终会被视图层调用。

我在其中，独立负责了业务层的竞品调研、需求产出、方案设计和实现，视图层的部分实现。

难点：

为了支持10W行300列的表格渲染，前期做了大量的调研和验证，最终采用canvas而不是dom进行表格的渲染。我们采用了一个叫做zrender的对canvas二次封装的库来实现对canvas的操作，在这个插件中的一部分组件实现了一些鼠标事件的监听，使得canvas可以响应鼠标事件。但是对于文本类型的节点无事件行为。我们的需求中有支持链接点击跳转及hover到人名上显示用户信息卡片的能力。于是我在网上查找资料没有找到相应的解决方案后，下载了zrender的源码及其官方实例，通过debug的方式确认生成文本的过程，通过修改源码的方式为富文本添加了click和hover事件。

**排版**：在单元格的展示中，遇到有一个单元格内展示多个元素的情况下，会有列宽小于元素整体宽度的情况。这种时候canvas并不会自动换行，而是直接截断，如果不统一处理，需要每一种列类型自定义实现计算布局和排版的能力，这样的话，业务开发就需要额外的精力去考虑布局的问题。所以提供了一个通过计算单元格内元素的大小及位置自动换行的能力。业务方需要的话，就调用这个接口，传入一些参数即可。

**优化请求：**

在渲染的过程中，需要对人员数据进行请求，做了一个逻辑优化，通过延迟promise执行的方式，对请求进行了合并与分发。

**逻辑抽象：**

业务层和视图层的代码耦合比较严重，经常会遇到需求改了，导致视图层的逻辑不适配，改动量会超级大，或者需要传入更多的参数给视图层。所以对业务进行了统一的抽象，尽量将与业务逻辑相关的能力全部抽取到业务层。视图层只关注表格的样子，不关心表格可以做什么。

**富文本编辑器**

富文本编辑器的存储格式，通过定义统一的格式，虽然格式本身很简单，但是由于涉及到灰度上线、三方接入等场景、需要综合考虑来决定最终的数据。

#### 性能优化

数据是美团内部的性能监控平台上的，这个数据是TP90数据（百分之90的用户都在2800ms之内），所以在本地很难有比较慢的耗时。所以采用控制变量的方式，通过对比同类型的项目在同一时间端的性能情况进行分析，最终得到js资源耗时是主要问题。所以进行了拆包利用http2并发提升加载速度，利用异步加载非关键资源减少首屏请求数量。

#### Promise延迟执行口语化表达

如何保证promise执行并且只调用一次：

封装一个defferedPromise,在defferedPromise中持有一个promise,并将持有的这个promsie的resolve和reject方法暴露，利用防抖去重，每次调用方法都new一个新的DeferredPromise,将DeferredPromise入队，返回一个pending的promise，这个promsie就是DeferredPromise中保存的promise.等最终请求结果返回的时候，将队列中的deferredPromise执行掉。

#### 加密过程细化：

https加密，

